st_write(pv_spain_joined, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE, quiet = TRUE)
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.list), ~as.character(.)))
st_write(pv_spain_joined, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE, quiet = TRUE)
pv_spain_joined <- pv_spain_joined %>% clean_names()
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.factor), as.character))
# Convertir listas a texto concatenado
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.list), ~ sapply(., function(x) paste(x, collapse = ", "))))
st_write(pv_spain_joined, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE, quiet = TRUE)
st_geometry(pv_spain_joined)
names(pv_spain_joined)
st_geometry(pv_spain_joined) <- "geometry"
pv_spain_joined <- pv_spain_joined %>% clean_names()
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.factor), as.character))
# Convertir listas a texto concatenado
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.list), ~ sapply(., function(x) paste(x, collapse = ", "))))
st_geometry(pv_spain_joined) <- "geometry"
st_write(pv_spain_joined, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE, quiet = TRUE)
# Mantener la geometría de allsolar (polígonos)
pv_spain_joined <- st_join(allsolar, pv_spain_excell, join = st_intersects)
# Verifica la geometría
st_geometry(pv_spain_joined)
pv_spain_joined <- pv_spain_joined %>%
clean_names() %>%
mutate(across(where(is.factor), as.character)) %>%
mutate(across(where(is.list), ~ sapply(., function(x) paste(x, collapse = ", "))))
st_write(pv_spain_joined, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE, quiet = TRUE)
pv_spain_excell <-st_read("data/pv_spain.gpkg", quiet = TRUE) #Previously created gpkg
allsolar <- st_read("data/allsolar_cut.shp", quiet = TRUE) #Polygon pv layer
#Assure same CRS
allsolar <- st_transform(allsolar, st_crs(pv_spain_excell))
#Join layers
st_geometry_type(allsolar)
pv_spain_join <- st_join(allsolar, pv_spain_excell, join = st_intersects)
pv_spain_joined <- pv_spain_joined %>%
clean_names()
# Convertir factores a character (excepto geometría)
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.factor), as.character))
# Convertir listas a character, **pero ignorar la geometría**
geometry_col <- attr(pv_spain_joined, "sf_column")
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.list) & !names(.) %in% geometry_col, ~ sapply(., function(x) paste(x, collapse = ", "))))
#Assure same CRS
allsolar <- st_transform(allsolar, st_crs(pv_spain_excell))
#Join layers
st_geometry_type(allsolar)
pv_spain_join <- st_join(allsolar, pv_spain_excell, join = st_intersects)
geom_col <- attr(pv_spain_joined, "sf_column")
# Convertir factores a character en todas las columnas excepto geometría
cols_to_mutate <- setdiff(names(pv_spain_joined), geom_col)
pv_spain_joined <- pv_spain_joined %>%
clean_names() %>%
mutate(across(all_of(cols_to_mutate), ~ if(is.factor(.)) as.character(.) else .)) %>%
mutate(across(all_of(cols_to_mutate), ~ if(is.list(.)) sapply(., function(x) paste(x, collapse = ", ")) else .))
# Reconstruir la geometría para asegurarse que sigue siendo sf
st_geometry(pv_spain_joined) <- geom_col
st_geometry(pv_spain_joined)
pv_spain_joined <- pv_spain_joined %>%
clean_names() %>%
mutate(across(all_of(cols_to_mutate), ~ if(is.factor(.)) as.character(.) else .)) %>%
mutate(across(all_of(cols_to_mutate), ~ if(is.list(.)) sapply(., function(x) paste(x, collapse = ", ")) else .))
library(sf)
library(dplyr)
library(janitor)
pv_spain_excell <-st_read("data/pv_spain.gpkg", quiet = TRUE) #Previously created gpkg
allsolar <- st_read("data/allsolar_cut.shp", quiet = TRUE) #Polygon pv layer
#Assure same CRS
allsolar <- st_transform(allsolar, st_crs(pv_spain_excell))
#Join layers
st_geometry_type(allsolar)
pv_spain_join <- st_join(allsolar, pv_spain_excell, join = st_intersects)
# Asegurarse de que tenemos la geometría original
geom_col <- attr(pv_spain_join, "sf_column") # debería ser "geometry" o similar
print(geom_col)
# Hacer todas las transformaciones, **excluyendo la geometría**
pv_spain_joined <- pv_spain_join %>%
clean_names() %>%
mutate(across(where(is.factor), as.character)) %>%
mutate(across(
.cols = !names(.) %in% geom_col & where(is.list),
.fns = ~ sapply(., function(x) paste(x, collapse = ", "))
))
pv_spain_excell <-st_read("data/pv_spain.gpkg", quiet = TRUE) #Previously created gpkg
allsolar <- st_read("data/allsolar_cut.shp", quiet = TRUE) #Polygon pv layer
#Assure same CRS
allsolar <- st_transform(allsolar, st_crs(pv_spain_excell))
pv_spain_joined <- pv_spain_joined %>%
mutate(across(where(is.factor), as.character)) %>%
mutate(across(where(is.list), ~ sapply(., function(x) paste(x, collapse = ", "))))
# Comprobar geometría
geom_col <- attr(pv_spain_joined, "sf_column")
print(geom_col)  # debería devolver "geometry"
# Guardar resultado
st_write(pv_spain_joined, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE, quiet = TRUE)
pv_spain_excell <-st_read("data/pv_spain.gpkg", quiet = TRUE) #Previously created gpkg
allsolar <- st_read("data/allsolar_cut.shp", quiet = TRUE) #Polygon pv layer
allsolar <- st_transform(allsolar, st_crs(pv_spain_excell))
# Join espacial
pv_spain_joined <- st_join(allsolar, pv_spain_excell, join = st_intersects)
# Nombre de la geometría
geom_col <- attr(pv_spain_joined, "sf_column")
# Limpiar nombres y convertir factores/listas **sin tocar geometría**
pv_spain_joined <- pv_spain_joined %>%
clean_names() %>%
mutate(across(where(is.factor), as.character)) %>%
mutate(across(where(is.list), ~ sapply(., function(x) paste(x, collapse = ", ")), .names = "{.col}"))
# **Reafirmar la geometría explícitamente** antes de guardar
st_geometry(pv_spain_joined) <- geom_col
# Guardar resultado
st_write(pv_spain_joined, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE)
library(sf)
library(dplyr)
library(janitor)
# Leer capas
pv_spain_excell <- st_read("data/pv_spain.gpkg", quiet = TRUE)
allsolar <- st_read("data/allsolar_cut.shp", quiet = TRUE)
# Asegurar CRS idéntico
allsolar <- st_transform(allsolar, st_crs(pv_spain_excell))
# Join espacial (polígonos sobre puntos)
joined <- st_join(allsolar, pv_spain_excell, join = st_intersects)
# Limpiar nombres (solo las columnas de datos, no la geometría)
joined_clean <- joined %>%
clean_names()
# Extraer solo la geometría original de 'allsolar' y columnas clave
cols_to_keep <- c("project_name", "start_year", "capacity_mw") # ajustar según nombres limpios
joined_final <- joined_clean %>%
select(all_of(cols_to_keep), geometry)  # geometry al final
# Verificar geometría
st_geometry(joined_final)  # debería devolver 'geometry'
# Guardar seguro en GeoPackage
st_write(joined_final, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE)
View(pv_spain_join)
rm(pv_spain_join, pv_spain_joined)
gc()
library(sf)
library(dplyr)
library(janitor)
# Leer capas
pv_spain_excell <- st_read("data/pv_spain.gpkg", quiet = TRUE)
allsolar <- st_read("data/allsolar_cut.shp", quiet = TRUE)
# Asegurar CRS idéntico
allsolar <- st_transform(allsolar, st_crs(pv_spain_excell))
# Join espacial (polígonos sobre puntos)
joined <- st_join(allsolar, pv_spain_excell, join = st_intersects)
# Limpiar nombres (solo las columnas de datos, no la geometría)
joined_clean <- joined %>%
clean_names()
# Extraer solo la geometría original de 'allsolar' y columnas clave
cols_to_keep <- c("project_name", "start_year", "capacity_mw") # ajustar según nombres limpios
joined_final <- joined_clean %>%
select(all_of(cols_to_keep), geometry)  # geometry al final
# Verificar geometría
st_geometry(joined_final)  # debería devolver 'geometry'
# Guardar seguro en GeoPackage
st_write(joined_final, "data/allsolar_Spain_joined.gpkg", delete_layer = TRUE)
library(sf)
library(dplyr)
library(mapview)
pv_spain_excell <- st_read("data/pv_spain.gpkg", quiet = TRUE)
allsolar <- st_read("data/allsolar_cut_diss.shp", quiet = TRUE)
# Assure same CRS
allsolar <- st_transform(allsolar, 4326)
pv_spain_excell <- st_transform(pv_spain_excell, 4326)
# Filter only operating plants
pv_spain_excell <- pv_spain_excell %>% filter(Status == "operating")
# Create id for each obs.
pv_spain_excell <- pv_spain_excell %>% mutate(point_id = row_number())
allsolar <- allsolar %>% mutate(poly_id = row_number())
# Repair invalid geometries
allsolar <- st_make_valid(allsolar)
# Remove duplicates vertices
allsolar <- st_buffer(allsolar, 0)
# Polygon centroids
poly_centroids <- st_centroid(allsolar)
# Assign nearest PV point
nearest_idx <- st_nearest_feature(poly_centroids, pv_spain_excell)
assign_nearest <- tibble(
poly_id = allsolar$poly_id,
nearest_idx = nearest_idx
) %>%
mutate(
point_id = pv_spain_excell$point_id[nearest_idx],
project_name = pv_spain_excell$Project.Name[nearest_idx],
start_year = pv_spain_excell$`Start.year`[nearest_idx],
capacity_mw = pv_spain_excell$`Capacity..MW.`[nearest_idx]
)
# Spatial join: associate each PV polygon with the closest PV point metadata
allsolar_assigned_nearest <- allsolar %>%
left_join(assign_nearest %>% select(poly_id, point_id, project_name, start_year, capacity_mw),
by = "poly_id")
# Distances from each polygon to its assigned PV point
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(distance_m = as.numeric(st_distance(
st_transform(st_centroid(geometry), 3857),
st_transform(pv_spain_excell[match(point_id, pv_spain_excell$point_id), ], 3857),
by_element = TRUE
)))
# --- New step: Estimate area-based radius for validation ---
# Use your Spanish MW → ha relationship: 0.452 MW/ha
allsolar_assigned <- allsolar_assigned %>%
mutate(
estimated_area_ha = capacity_mw / 0.452,                   # estimate area
max_allow_m = sqrt(estimated_area_ha * 10000 / pi),        # convert area to radius in meters
assigned_valid = distance_m <= max_allow_m                 # TRUE if polygon is within plant radius
)
# --- New step: Estimate area-based radius for validation ---
# Use your Spanish MW → ha relationship: 0.452 MW/ha
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
estimated_area_ha = capacity_mw / 0.452,                   # estimate area
max_allow_m = sqrt(estimated_area_ha * 10000 / pi),        # convert area to radius in meters
assigned_valid = distance_m <= max_allow_m                 # TRUE if polygon is within plant radius
)
View(allsolar_assigned_nearest)
# --- Optional QC: mark outliers without losing data ---
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
table(allsolar_assigned_nearest$assigned_valid)
# Mapview
mapview(allsolar_assigned_nearest, zcol = "distance_m")  # visualize all polygons colored by distance
pv_points <- st_read("data/pv_spain.gpkg", quiet = TRUE) %>%
st_transform(4326)  # mismo CRS que los polígonos
# Mapview
poligonos_validos <- allsolar_assigned %>% filter(assigned_valid)
# Mapview
poligonos_validos <- allsolar_assigned_nearest %>% filter(assigned_valid)
pv_points <- st_read("data/pv_spain.gpkg", quiet = TRUE) %>%
st_transform(4326)  # mismo CRS que los polígonos
mapview(poligonos_validos, zcol = "distance_m", col.regions = "green", legend = TRUE) +
mapview(pv_points, col.region = "red", cex = 5, alpha = 0.7, legend = FALSE)
# Mapview grouped by assigned_valid
poligonos_validos <- allsolar_assigned_nearest %>% filter(!assigned_valid)
pv_points <- st_read("data/pv_spain.gpkg", quiet = TRUE) %>%
st_transform(4326)
mapview(poligonos_validos, zcol = "distance_m", col.regions = "green", legend = TRUE) +
mapview(pv_points, col.region = "red", cex = 5, alpha = 0.7, legend = FALSE)
mapview(poligonos_validos, zcol = "distance_m", col.regions = "green", legend = TRUE) +
mapview(pv_spain_excell, col.region = "red", cex = 5, alpha = 0.7, legend = FALSE)
library(sf)
library(dplyr)
library(mapview)
pv_spain_excell <- st_read("data/pv_spain.gpkg", quiet = TRUE)
allsolar <- st_read("data/allsolar_cut_diss.shp", quiet = TRUE)
# Assure same CRS
allsolar <- st_transform(allsolar, 4326)
pv_spain_excell <- st_transform(pv_spain_excell, 4326)
# Filter only operating plants
pv_spain_excell <- pv_spain_excell %>% filter(Status == "operating")
# Create id for each obs.
pv_spain_excell <- pv_spain_excell %>% mutate(point_id = row_number())
allsolar <- allsolar %>% mutate(poly_id = row_number())
# Repair invalid geometries
allsolar <- st_make_valid(allsolar)
# Remove duplicates vertices
allsolar <- st_buffer(allsolar, 0)
# Assign nearest PV point
nearest_idx <- st_nearest_feature(allsolar, pv_spain_excell)
assign_nearest <- tibble(
poly_id = allsolar$poly_id,
nearest_idx = nearest_idx
) %>%
mutate(
point_id = pv_spain_excell$point_id[nearest_idx],
project_name = pv_spain_excell$Project.Name[nearest_idx],
start_year = pv_spain_excell$`Start.year`[nearest_idx],
capacity_mw = pv_spain_excell$`Capacity..MW.`[nearest_idx]
)
# Spatial join: associate each PV polygon with the closest PV point metadata
allsolar_assigned_nearest <- allsolar %>%
left_join(assign_nearest %>% select(poly_id, point_id, project_name, start_year, capacity_mw),
by = "poly_id")
# Distances from each polygon to its assigned PV point
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(distance_m = as.numeric(st_distance(
st_transform(st_centroid(geometry), 3857),
st_transform(pv_spain_excell[match(point_id, pv_spain_excell$point_id), ], 3857),
by_element = TRUE
)))
# Estimate area-based radius for validation (MW → ha relationship: 0.452 MW/ha)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
estimated_area_ha = capacity_mw / 0.452,                   # estimate area
max_allow_m = sqrt(estimated_area_ha * 10000 / pi),        # convert area to radius in meters
assigned_valid = distance_m <= max_allow_m                 # TRUE if polygon is within plant radius
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
table(allsolar_assigned_nearest$assigned_valid)
# Mapview
mapview(allsolar_assigned_nearest, zcol = "distance_m")  # visualize all polygons colored by distance
# Mapview grouped by assigned_valid
poligonos_validos <- allsolar_assigned_nearest %>% filter(assigned_valid)
mapview(poligonos_validos, zcol = "distance_m", col.regions = "green", legend = TRUE) +
mapview(pv_spain_excell, col.region = "red", cex = 5, alpha = 0.7, legend = FALSE)
# Estimate area-based radius for validation (MW → ha relationship: 0.452 MW/ha)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
estimated_area_ha = capacity_mw / 0.452,                   # estimate area
max_allow_m = sqrt((estimated_area_ha * 10000 )/ pi),        # convert area to radius in meters
assigned_valid = distance_m <= max_allow_m                 # TRUE if polygon is within plant radius
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
table(allsolar_assigned_nearest$assigned_valid)
# Estimate area-based radius for validation (MW → ha relationship: 0.452 MW/ha)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
estimated_area_ha = capacity_mw / 0.352,                   # estimate area
max_allow_m = sqrt((estimated_area_ha * 10000 )/ pi),        # convert area to radius in meters
assigned_valid = distance_m <= max_allow_m                 # TRUE if polygon is within plant radius
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
table(allsolar_assigned_nearest$assigned_valid)
# Spatial join: associate each PV polygon with the closest PV point metadata
allsolar_assigned_nearest <- allsolar %>%
left_join(assign_nearest %>% select(poly_id, point_id, project_name, start_year, capacity_mw),
by = "poly_id")
# Distances from each polygon to its assigned PV point
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(distance_m = as.numeric(st_distance(
st_transform(st_centroid(geometry), 3857),
st_transform(pv_spain_excell[match(point_id, pv_spain_excell$point_id), ], 3857),
by_element = TRUE
)))
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
View(assign_nearest)
View(allsolar_assigned_nearest)
# Estimate area-based radius for validation (MW → ha relationship: 0.452 MW/ha)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
estimated_area_ha = capacity_mw / 0.452,                   # estimate area
max_allow_m = sqrt((estimated_area_ha * 10000 )/ pi),        # convert area to radius in meters
assigned_valid = distance_m <= max_allow_m                 # TRUE if polygon is within plant radius
)
View(allsolar_assigned_nearest)
library(sf)
library(dplyr)
library(mapview)
pv_spain_excell <- st_read("data/pv_spain.gpkg", quiet = TRUE)
allsolar <- st_read("data/allsolar_cut_diss.shp", quiet = TRUE)
# Assure same CRS
allsolar <- st_transform(allsolar, 4326)
pv_spain_excell <- st_transform(pv_spain_excell, 4326)
# Filter only operating plants
pv_spain_excell <- pv_spain_excell %>% filter(Status == "operating")
# Create id for each obs.
pv_spain_excell <- pv_spain_excell %>% mutate(point_id = row_number())
allsolar <- allsolar %>% mutate(poly_id = row_number())
# Repair invalid geometries
allsolar <- st_make_valid(allsolar)
# Remove duplicates vertices
allsolar <- st_buffer(allsolar, 0)
# Polygon centroids
poly_centroids <- st_centroid(allsolar)
# Assign nearest PV point
nearest_idx <- st_nearest_feature(allsolar, pv_spain_excell)
assign_nearest <- tibble(
poly_id = allsolar$poly_id,
nearest_idx = nearest_idx
) %>%
mutate(
point_id = pv_spain_excell$point_id[nearest_idx],
project_name = pv_spain_excell$Project.Name[nearest_idx],
start_year = pv_spain_excell$`Start.year`[nearest_idx],
capacity_mw = pv_spain_excell$`Capacity..MW.`[nearest_idx]
)
# Spatial join: associate each PV polygon with the closest PV point metadata
allsolar_assigned_nearest <- allsolar %>%
left_join(assign_nearest %>% select(poly_id, point_id, project_name, start_year, capacity_mw),
by = "poly_id")
# Distances from each polygon to its assigned PV point
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(distance_m = as.numeric(st_distance(
st_transform(st_centroid(geometry), 3857),
st_transform(pv_spain_excell[match(point_id, pv_spain_excell$point_id), ], 3857),
by_element = TRUE
)))
# Estimate area-based radius for validation (MW → 2–5 ha/MW)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
min_area_ha = capacity_mw * 2,    # 2 ha/MW
max_area_ha = capacity_mw * 5,    # 5 ha/MW
min_allow_m = sqrt((min_area_ha * 10000) / pi),  # min. radius
max_allow_m = sqrt((max_area_ha * 10000) / pi),  # max. radius
assigned_valid = distance_m >= min_allow_m & distance_m <= max_allow_m
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
# Distances from each polygon to its assigned PV point
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(distance_m = as.numeric(st_distance(
st_transform(st_centroid(geometry), 3857),
st_transform(pv_spain_excell[match(point_id, pv_spain_excell$point_id), ], 3857),
by_element = TRUE
)))
# Estimate area-based radius for validation (MW → 2–5 ha/MW)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
min_area_ha = capacity_mw * 2,    # 2 ha/MW
max_area_ha = capacity_mw * 5,    # 5 ha/MW
min_allow_m = sqrt((min_area_ha * 10000) / pi),  # min. radius
max_allow_m = sqrt((max_area_ha * 10000) / pi),  # max. radius
assigned_valid = distance_m >= min_allow_m & distance_m <= max_allow_m
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
table(allsolar_assigned_nearest$assigned_valid)
# Estimate area-based radius for validation (MW → 2–5 ha/MW)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
max_area_ha = capacity_mw * 5,    # 5 ha/MW
max_allow_m = sqrt((max_area_ha * 10000) / pi),  # max. radius
assigned_valid = distance_m >= min_allow_m & distance_m <= max_allow_m
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
table(allsolar_assigned_nearest$assigned_valid)
# Estimate area-based radius for validation (MW → 2–5 ha/MW)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
max_area_ha = capacity_mw * 5,    # 5 ha/MW
max_allow_m = sqrt((max_area_ha * 10000) / pi),  # max. radius
assigned_valid = distance_m <= max_allow_m
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
table(allsolar_assigned_nearest$assigned_valid)
# Second attempt: join pv_spain.gpkg (obteined from Global PV Excell) and allsolar_cut.shp (Polygon PV Shapefile)
library(sf)
library(dplyr)
library(mapview)
pv_spain_excell <- st_read("data/pv_spain.gpkg", quiet = TRUE)
allsolar <- st_read("data/allsolar_cut_diss.shp", quiet = TRUE)
# Assure same CRS
allsolar <- st_transform(allsolar, 4326)
pv_spain_excell <- st_transform(pv_spain_excell, 4326)
# Filter only operating plants
pv_spain_excell <- pv_spain_excell %>% filter(Status == "operating")
# Create id for each obs.
pv_spain_excell <- pv_spain_excell %>% mutate(point_id = row_number())
allsolar <- allsolar %>% mutate(poly_id = row_number())
# Repair invalid geometries
allsolar <- st_make_valid(allsolar)
# Remove duplicates vertices
allsolar <- st_buffer(allsolar, 0)
# Assign nearest PV point
nearest_idx <- st_nearest_feature(allsolar, pv_spain_excell)
assign_nearest <- tibble(
poly_id = allsolar$poly_id,
nearest_idx = nearest_idx
) %>%
mutate(
point_id = pv_spain_excell$point_id[nearest_idx],
project_name = pv_spain_excell$Project.Name[nearest_idx],
start_year = pv_spain_excell$`Start.year`[nearest_idx],
capacity_mw = pv_spain_excell$`Capacity..MW.`[nearest_idx]
)
# Spatial join: associate each PV polygon with the closest PV point metadata
allsolar_assigned_nearest <- allsolar %>%
left_join(assign_nearest %>% select(poly_id, point_id, project_name, start_year, capacity_mw),
by = "poly_id")
# Distances from each polygon to its assigned PV point
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(distance_m = as.numeric(st_distance(
st_transform(geometry, 3857),
st_transform(pv_spain_excell[match(point_id, pv_spain_excell$point_id), ], 3857),
by_element = TRUE
)))
# Estimate area-based radius for validation (MW → 2–5 ha/MW)
allsolar_assigned_nearest <- allsolar_assigned_nearest %>%
mutate(
max_area_ha = capacity_mw * 5,    # 5 ha/MW
max_allow_m = sqrt((max_area_ha * 10000) / pi),  # max. radius
assigned_valid = distance_m <= max_allow_m
)
# QC
summary(allsolar_assigned_nearest$distance_m)
sum(!is.na(allsolar_assigned_nearest$point_id))
outliers <- allsolar_assigned_nearest %>% filter(!assigned_valid)
table(allsolar_assigned_nearest$assigned_valid)
# Mapview grouped by assigned_valid
poligonos_validos <- allsolar_assigned_nearest %>% filter(assigned_valid)
mapview(poligonos_validos, zcol = "distance_m", col.regions = "green", legend = TRUE) +
mapview(pv_spain_excell, col.region = "red", cex = 5, alpha = 0.7, legend = FALSE)
# Mapview grouped by assigned_valid
poligonos_validos <- allsolar_assigned_nearest %>% filter(!assigned_valid)
mapview(poligonos_validos, zcol = "distance_m", col.regions = "green", legend = TRUE) +
mapview(pv_spain_excell, col.region = "red", cex = 5, alpha = 0.7, legend = FALSE)

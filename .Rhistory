pv_name = pv_names[similar_pairs[,1]],
osm_name = osm_names[similar_pairs[,2]],
distance = name_matches[similar_pairs]
)
print(similar_df)
}
}
View(similar_pairs)
if(nrow(potential_dups) > 0){
cat("Potential duplicates detected:", nrow(potential_dups), "\n")
mapview(potential_dups, col.regions = "red")
} else {
cat("No residual duplicates detected.\n")
}
# --- 8. Optional: check by name similarity ---
if("Project.Name" %in% names(pv_sf) & "name" %in% names(solar_plants)){
pv_names <- pv_sf$Project.Name
osm_names <- osm_discarded$name
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
similar_pairs <- which(name_matches <= 2, arr.ind = TRUE)
if(length(similar_pairs) > 0){
similar_df <- data.frame(
pv_name = pv_names[similar_pairs[,1]],
osm_name = osm_names[similar_pairs[,2]],
distance = name_matches[similar_pairs]
)
print(similar_df)
}
}
similar_df()
print(similar_df)
View(similar_pairs)
# 1. Read pv_spain.csv
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_plants <- bind_rows(
st_make_valid(spain_solar$osm_polygons),
st_make_valid(spain_solar$osm_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Remove OSM duplicates by proximity to pv_spain
osm_points <- st_centroid(solar_plants)
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
threshold <- set_units(500, "m")
osm_unique <- osm_points[distances > threshold, ]
osm_discarded <- osm_points[distances <= threshold, ]
# 4. Combine layers
combined_pv <- bind_rows(st_make_valid(pv_sf), st_make_valid(osm_unique))
# 7. Optional: check name similarity for discarded OSM
if("Project.Name" %in% names(pv_sf) & "name" %in% names(osm_discarded)){
pv_names <- pv_sf$Project.Name
osm_names <- osm_discarded$name
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
similar_pairs <- which(name_matches <= 2, arr.ind = TRUE)
if(length(similar_pairs) > 0){
similar_df <- data.frame(
pv_name = pv_names[similar_pairs[,1]],
osm_name = osm_names[similar_pairs[,2]],
distance = name_matches[similar_pairs]
)
print(similar_df)
}
}
View(solar_plants)
# 1. Read pv_spain.csv
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_plants <- bind_rows(
st_make_valid(spain_solar$osm_polygons),
st_make_valid(spain_solar$osm_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# Prepare names (remove NAs)
pv_names <- pv_sf$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$name[!is.na(solar_plants$name)]
# Compute string distances
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2  # ajusta según tu criterio de similitud
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# Optional: check how many duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# Threshold for considering two names as duplicates
threshold <- 1  # ajusta según tu criterio de similitud
qu
# Threshold for considering two names as duplicates
threshold <- 1  # ajusta según tu criterio de similitud
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# Optional: check how many duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# Prepare names (remove NAs)
pv_names <- pv_sf$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$name[!is.na(solar_plants$name)]
# Compute string distances
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 0  # ajusta según tu criterio de similitud
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# Optional: check how many duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
View(combined_pv)
View(combined_pv)
View(combined_pv)
# 5. Check how many OSM duplicates were removed
nrow(combined_pv)
# 5. Check how many OSM duplicates were removed
nrow(osm_unique)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE SCRIPT ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(stringdist)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert CSV points to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- spain_solar$osm_polygons
solar_multipolygons <- spain_solar$osm_multipolygons
# Make geometries valid and combine
solar_plants <- bind_rows(
st_make_valid(solar_polygons),
st_make_valid(solar_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Remove OSM duplicates by name
# Prepare names (remove NAs)
pv_names <- pv_sf$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$Project.Name[!is.na(solar_plants$Project.Name)]
# Compute string distances (Levenshtein distance)
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# 4. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.shp", delete_layer = TRUE)
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# 7. Quick visualization
x11()
mapview(pv_sf, col.regions = "blue", cex = 3, alpha = 0.6, legend = TRUE) +
mapview(osm_unique, col.regions = "orange", alpha = 0.7, legend = TRUE)
names(combined_pv)[duplicated(names(combined_pv))]
# --- 3. Normalize column names to avoid truncation issues ---
normalize_names <- function(x) {
x <- gsub("[^A-Za-z0-9_]", "_", x)
make.unique(x)
}
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert CSV points to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- spain_solar$osm_polygons
solar_multipolygons <- spain_solar$osm_multipolygons
# Make geometries valid and combine
solar_plants <- bind_rows(
st_make_valid(solar_polygons),
st_make_valid(solar_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# --- 3. Normalize column names to avoid truncation issues ---
normalize_names <- function(x) {
x <- gsub("[^A-Za-z0-9_]", "_", x)
make.unique(x)
}
names(pv_sf) <- normalize_names(names(pv_sf))
names(solar_plants) <- normalize_names(names(solar_plants))
# 3. Remove OSM duplicates by name
# Prepare names (remove NAs)
pv_names <- pv_spain$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$Project.Name[!is.na(solar_plants$Project.Name)]
# Compute string distances (Levenshtein distance)
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# 4. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert CSV points to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- spain_solar$osm_polygons
solar_multipolygons <- spain_solar$osm_multipolygons
# Make geometries valid and combine
solar_plants <- bind_rows(
st_make_valid(solar_polygons),
st_make_valid(solar_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# --- 3. Normalize column names to avoid truncation issues ---
normalize_names <- function(x) {
x <- gsub("[^A-Za-z0-9_]", "_", x)
make.unique(x)
}
names(pv_sf) <- normalize_names(names(pv_sf))
names(solar_plants) <- normalize_names(names(solar_plants))
# 3. Remove OSM duplicates by name
# Prepare names (remove NAs)
pv_names <- pv_spain$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$Project.Name[!is.na(solar_plants$Project.Name)]
# Compute string distances (Levenshtein distance)
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# 4. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert CSV points to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- spain_solar$osm_polygons
solar_multipolygons <- spain_solar$osm_multipolygons
# Make geometries valid and combine
solar_plants <- bind_rows(
st_make_valid(solar_polygons),
st_make_valid(solar_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Remove OSM duplicates by name
# Prepare names (remove NAs)
pv_names <- pv_spain$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$Project.Name[!is.na(solar_plants$Project.Name)]
# Compute string distances (Levenshtein distance)
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# 4. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE USING DISTANCE CRITERION ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep only operating plants
pv_spain <- pv_spain %>% filter(Status == "operating")
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
# 8. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 9. Mapview visualization: combined + discarded
x11()
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE USING DISTANCE CRITERION ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep only operating plants
pv_spain <- pv_spain %>% filter(Status == "operating")
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
#Clean column names to avoid duplicates
clean_names <- function(sf_object){
names(sf_object) <- make.names(names(sf_object), unique = TRUE)
return(sf_object)
}
pv_sf <- clean_names(pv_sf)
osm_unique <- clean_names(osm_unique)
combined_pv <- clean_names(combined_pv)
osm_discarded <- clean_names(osm_discarded)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
# 8. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 9. Mapview visualization: combined + discarded
x11()
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE USING DISTANCE CRITERION ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep only operating plants
pv_spain <- pv_spain %>% filter(Status == "operating")
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
pv_sf <- clean_names(pv_sf)
osm_unique <- clean_names(osm_unique)
combined_pv <- clean_names(combined_pv)
osm_discarded <- clean_names(osm_discarded)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity.MW, Start.Year, geometry)
View(pv_sf)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
pv_sf <- clean_names(pv_sf)
osm_unique <- clean_names(osm_unique)
combined_pv <- clean_names(combined_pv)
osm_discarded <- clean_names(osm_discarded)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity.MW, Start.Year, geometry)
View(pv_sf)
View(pv_sf)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity.MW, Start.Year, geometry)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity..MW., Start.Year, geometry)
View(pv_sf)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity..MW., Start.year, geometry)
osm_unique_sel <- osm_unique %>% select(Project.Name, Capacity..MW., Start.year, geometry)
View(osm_unique)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity..MW., Start.year, geometry)
osm_unique <- osm_unique %>% select(name)
# 8. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
mapview(combined_pv, col.regions = "orange", cex = 5, alpha = 0.5, legend = FALSE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.7, legend = FALSE)
View(osm_unique)

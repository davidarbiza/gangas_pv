# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.shp", delete_layer = TRUE)
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# 7. Quick visualization
x11()
mapview(pv_sf, col.regions = "blue", cex = 3, alpha = 0.6, legend = TRUE) +
mapview(osm_unique, col.regions = "orange", alpha = 0.7, legend = TRUE)
names(combined_pv)[duplicated(names(combined_pv))]
# --- 3. Normalize column names to avoid truncation issues ---
normalize_names <- function(x) {
x <- gsub("[^A-Za-z0-9_]", "_", x)
make.unique(x)
}
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert CSV points to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- spain_solar$osm_polygons
solar_multipolygons <- spain_solar$osm_multipolygons
# Make geometries valid and combine
solar_plants <- bind_rows(
st_make_valid(solar_polygons),
st_make_valid(solar_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# --- 3. Normalize column names to avoid truncation issues ---
normalize_names <- function(x) {
x <- gsub("[^A-Za-z0-9_]", "_", x)
make.unique(x)
}
names(pv_sf) <- normalize_names(names(pv_sf))
names(solar_plants) <- normalize_names(names(solar_plants))
# 3. Remove OSM duplicates by name
# Prepare names (remove NAs)
pv_names <- pv_spain$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$Project.Name[!is.na(solar_plants$Project.Name)]
# Compute string distances (Levenshtein distance)
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# 4. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert CSV points to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- spain_solar$osm_polygons
solar_multipolygons <- spain_solar$osm_multipolygons
# Make geometries valid and combine
solar_plants <- bind_rows(
st_make_valid(solar_polygons),
st_make_valid(solar_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# --- 3. Normalize column names to avoid truncation issues ---
normalize_names <- function(x) {
x <- gsub("[^A-Za-z0-9_]", "_", x)
make.unique(x)
}
names(pv_sf) <- normalize_names(names(pv_sf))
names(solar_plants) <- normalize_names(names(solar_plants))
# 3. Remove OSM duplicates by name
# Prepare names (remove NAs)
pv_names <- pv_spain$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$Project.Name[!is.na(solar_plants$Project.Name)]
# Compute string distances (Levenshtein distance)
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# 4. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert CSV points to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- spain_solar$osm_polygons
solar_multipolygons <- spain_solar$osm_multipolygons
# Make geometries valid and combine
solar_plants <- bind_rows(
st_make_valid(solar_polygons),
st_make_valid(solar_multipolygons)
) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Remove OSM duplicates by name
# Prepare names (remove NAs)
pv_names <- pv_spain$Project.Name[!is.na(pv_sf$Project.Name)]
osm_names <- solar_plants$Project.Name[!is.na(solar_plants$Project.Name)]
# Compute string distances (Levenshtein distance)
name_matches <- stringdistmatrix(pv_names, osm_names, method = "lv")
# Threshold for considering two names as duplicates
threshold <- 2
# Find pairs with distance <= threshold
similar_pairs <- which(name_matches <= threshold, arr.ind = TRUE)
# Mark OSM entries to discard (duplicates)
osm_to_discard <- unique(osm_names[similar_pairs[,2]])
# Keep only unique OSM plants
osm_unique <- solar_plants[!(solar_plants$Project.Name %in% osm_to_discard), ]
# 4. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 5. Check how many OSM duplicates were removed
cat("Number of OSM plants discarded as duplicates:", length(osm_to_discard), "\n")
# 6. Save output
st_write(combined_pv, "data/pv_spain_osm_unique.gpkg", delete_layer = TRUE)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE USING DISTANCE CRITERION ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep only operating plants
pv_spain <- pv_spain %>% filter(Status == "operating")
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
# 8. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 9. Mapview visualization: combined + discarded
x11()
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE USING DISTANCE CRITERION ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep only operating plants
pv_spain <- pv_spain %>% filter(Status == "operating")
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
#Clean column names to avoid duplicates
clean_names <- function(sf_object){
names(sf_object) <- make.names(names(sf_object), unique = TRUE)
return(sf_object)
}
pv_sf <- clean_names(pv_sf)
osm_unique <- clean_names(osm_unique)
combined_pv <- clean_names(combined_pv)
osm_discarded <- clean_names(osm_discarded)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
# 8. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
# 9. Mapview visualization: combined + discarded
x11()
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE USING DISTANCE CRITERION ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep only operating plants
pv_spain <- pv_spain %>% filter(Status == "operating")
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
pv_sf <- clean_names(pv_sf)
osm_unique <- clean_names(osm_unique)
combined_pv <- clean_names(combined_pv)
osm_discarded <- clean_names(osm_discarded)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity.MW, Start.Year, geometry)
View(pv_sf)
# 1. Read pv_spain.csv and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Convert to sf points (WGS84)
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and multipolygons
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%  # Match CRS of pv_sf
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute centroids of OSM polygons
osm_points <- st_centroid(solar_plants)
# 4. Compute distances to nearest pv_spain point
nearest <- st_nearest_feature(osm_points, pv_sf)
distances <- st_distance(osm_points, pv_sf[nearest, ], by_element = TRUE)
pv_sf <- clean_names(pv_sf)
osm_unique <- clean_names(osm_unique)
combined_pv <- clean_names(combined_pv)
osm_discarded <- clean_names(osm_discarded)
# 5. Set distance threshold for considering duplicates
threshold <- set_units(500, "m")
# 6. Identify unique OSM plants
osm_unique <- osm_points[distances > threshold, ]
# 7. Identify discarded OSM plants
osm_discarded <- osm_points[distances <= threshold, ]
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity.MW, Start.Year, geometry)
View(pv_sf)
View(pv_sf)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity.MW, Start.Year, geometry)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity..MW., Start.Year, geometry)
View(pv_sf)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity..MW., Start.year, geometry)
osm_unique_sel <- osm_unique %>% select(Project.Name, Capacity..MW., Start.year, geometry)
View(osm_unique)
#4. Select only relevant columns to avoid duplicate names ---
pv_sf_sel <- pv_sf %>% select(Project.Name, Capacity..MW., Start.year, geometry)
osm_unique <- osm_unique %>% select(name)
# 8. Combine PV Spain + unique OSM plants
combined_pv <- bind_rows(pv_sf, osm_unique)
mapview(combined_pv, zcol = "Project.Name", col.regions = "orange", cex = 5, alpha = 0.7, legend = TRUE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.6, legend = FALSE)
mapview(combined_pv, col.regions = "orange", cex = 5, alpha = 0.5, legend = FALSE) +
mapview(osm_discarded, col.regions = "red", cex = 5, alpha = 0.7, legend = FALSE)
View(osm_unique)
# --- Step 1: Read pv_spain.csv and convert to sf ---
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
pv_sf <- st_as_sf(
pv_spain,
coords = c("Longitude", "Latitude"),
crs = 4326
)
library(sf)
library(dplyr)
library(mapview)
library(units)
# --- Step 1: Read pv_spain.csv and convert to sf ---
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
pv_sf <- st_as_sf(
pv_spain,
coords = c("Longitude", "Latitude"),
crs = 4326
)
# --- Step 2: Prepare OSM solar plants layer ---
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%
mutate(Project.Name = ifelse(!is.na(name), name, NA))
# --- Step 3: Compute distances between OSM polygons and pv_spain points ---
distances <- st_distance(st_boundary(solar_plants), pv_sf)
# For each OSM polygon, find nearest pv_spain point
nearest <- apply(distances, 1, which.min)
min_dist <- apply(distances, 1, min)
# --- Step 4: Filter unique vs duplicated OSM plants ---
threshold <- set_units(500, "m")
osm_unique <- solar_plants[min_dist > threshold, ]
osm_discarded <- solar_plants[min_dist <= threshold, ]
# --- PV SPAIN + OSM SOLAR PLANTS MERGE SCRIPT WITH DISTANCE FILTER AND CORRECT NAME HANDLING ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep only operating plants
pv_spain <- pv_spain %>%
filter(Status == "operating")
# Convert to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine and transform to WGS84
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute distances between PV Spain points and OSM polygons (using polygon borders)
nearest <- st_nearest_feature(solar_plants, pv_sf)
distances <- st_distance(solar_plants, pv_sf[nearest, ], by_element = TRUE)
# Set threshold for considering as duplicate (adjust as needed)
threshold <- set_units(500, "m")
# 4. Separate unique and discarded OSM entries
osm_unique <- solar_plants[distances > threshold, ]
osm_discarded <- solar_plants[distances <= threshold, ]
# Ensure discarded OSM entries have names
osm_discarded <- osm_discarded %>%
mutate(Project.Name = ifelse(!is.na(Project.Name), Project.Name, name))
# 5. Combine PV Spain points with unique OSM polygons
combined_pv <- bind_rows(pv_sf, osm_unique)
# 6. Mapview visualization
x11()
mapview(pv_sf, col.regions = "orange", alpha = 0.5, legend = FALSE, popup = "Project.Name") +
mapview(osm_unique, col.regions = "green", alpha = 0.5, legend = FALSE, popup = "Project.Name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.7, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "orange", alpha = 0.5, legend = FALSE, popup = "Project.Name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.7, legend = FALSE, popup = "Project.Name")
View(solar_plants)
inside_check <- osm_discarded[st_intersects(osm_discarded, pv_sf, sparse = FALSE), ]
cat("Number of OSM polygons that contain a PV Spain point:", nrow(inside_check), "\n")
mapview(pv_sf, col.regions = "blue", alpha = 0.6) +
mapview(inside_check, col.regions = "red", alpha = 0.4)
View(pv_spain)
# --- PV SPAIN + OSM SOLAR PLANTS MERGE SCRIPT WITH DISTANCE + INTERSECTS FILTER AND ADDITIONAL COLUMNS ---
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep all columns, but we highlight these for later use
cols_to_keep <- c("Project.Name" = "Project name", "Status", "Phase.Name" = "Phase name", "Location.accuracy" = "Location accuracy")
pv_spain <- pv_spain %>%
rename(
Project.Name = `Project name`,
Phase.Name = `Phase name`,
Location.accuracy = `Location accuracy`
)
View(pv_spain)
View(pv_spain)
colnames(pv_spain)
# Keep all columns, but we highlight these for later use
cols_to_keep <- c("Project.Name", "Status", "Phase.Name", "Location.accuracy")
pv_spain <- pv_spain %>%
rename(
Project.Name = `Project name`,
Phase.Name = `Phase name`,
Location.accuracy = `Location accuracy`
)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep all columns, but we highlight these for later use
cols_to_keep <- c("Project.Name" = "Project name", "Status", "Phase.Name" = "Phase name", "Location.accuracy" = "Location accuracy")
pv_spain <- pv_spain %>%
rename(
Project.Name = `Project name`,
Phase.Name = `Phase name`,
Location.accuracy = `Location accuracy`
)
library(sf)
library(dplyr)
library(mapview)
library(osmdata)
library(units)
# 1. Read PV Spain CSV and convert to sf
pv_spain <- read.csv("data/pv_spain.csv", stringsAsFactors = FALSE)
# Keep all columns, but rename key columns for consistency
pv_spain <- pv_spain %>%
rename(
`Project name` = Project.Name,
`Phase name` = Phase.Name,
`Location accuracy` = Location.accuracy
)
# Convert to sf object with WGS84 coordinates
pv_sf <- st_as_sf(pv_spain, coords = c("Longitude", "Latitude"), crs = 4326)
# 2. Prepare OSM solar plants layer
solar_polygons <- st_make_valid(spain_solar$osm_polygons)
solar_multipolygons <- st_make_valid(spain_solar$osm_multipolygons)
# Combine polygons and transform to WGS84
solar_plants <- bind_rows(solar_polygons, solar_multipolygons) %>%
st_transform(4326) %>%
mutate(
Project.Name = ifelse(!is.na(name), name, NA),
Capacity.MW = NA_real_,
Start.Year = NA_integer_
)
# 3. Compute nearest distances between PV Spain points and OSM polygons
nearest <- st_nearest_feature(solar_plants, pv_sf)
distances <- st_distance(solar_plants, pv_sf[nearest, ], by_element = TRUE)
# Threshold distance for considering as duplicate
threshold <- set_units(500, "m")
# 4. Intersects check (OSM polygons that contain a PV Spain point)
intersects_matrix <- st_intersects(solar_plants, pv_sf, sparse = FALSE)
inside <- rowSums(intersects_matrix) > 0
# 5. Discard OSM entries if too close or containing a PV Spain point
osm_discarded <- solar_plants[distances <= threshold | inside, ]
osm_unique <- solar_plants[!(distances <= threshold | inside), ]
# 6. Combine PV Spain points with unique OSM polygons
combined_pv <- bind_rows(pv_sf, osm_unique)
# 9. Stats
cat("Number of OSM polygons discarded as duplicates:", nrow(osm_discarded), "\n")
cat("Final plants in combined_pv:", nrow(combined_pv), "\n")
inside_check <- osm_discarded[st_intersects(osm_discarded, pv_sf, sparse = FALSE), ]
cat("Number of OSM polygons that contain a PV Spain point:", nrow(inside_check), "\n")
mapview(pv_sf, col.regions = "blue", alpha = 0.5, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.6, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "lightblue", alpha = 0.4, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.6, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "lightblue", alpha = 0.5, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.6, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "lightblue", alpha = 0.5, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.6, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "lightblue", alpha = 0.5, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.6, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "blue", alpha = 0.5, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.6, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "lightblue", alpha = 0.5, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "red", alpha = 0.6, legend = FALSE, popup = "Project.Name")
mapview(pv_sf, col.regions = "orange", alpha = 0.5, legend = FALSE, popup = "Project name") +
mapview(osm_discarded, col.regions = "blue", alpha = 0.6, legend = FALSE, popup = "Project.Name")
